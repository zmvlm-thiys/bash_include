#!/bin/bash
# path-tools(path) 1.0.0rc1: functions for path manipulation.
# functions:
#    path_remove_trailing_slash: gibt den pfad aus $1 ohne trailing slash auf stdout aus
#    path_simplify: gibt den pfad $1 vereinfacht auf stdout aus.
#    path_absolute: gibt den absoluten pfad vom zu $1 relativem pfad $2 (ist $2 nicht gegeben,
#                   zu $PWD relativem $1) aus.
#    path_relative: gibt den relativen pfad von $1 zu $2 (ist $2 nicht gegeben, von PWD zu $1)
#                   auf stdout aus.
#  fuer alle bis hier funktionen gilt, ist $1 nicht gegeben, wird inhalt von stdin als $1 genommen.
#
#    path_is_absolute: gibt 0 zurueck, wenn der pfad aus $1 absolut ist.
#    path_is_relative: gibt 0 zurueck, wenn der pfad aus $1 relativ ist.
#
SCRIPT_NAME="path"
SCRIPT_PREFIX="path"
SCRIPT_VERSION="1.0.0rc1"
SCRIPT_DESCRIPTION="tools for manipulation of path strings"
SCRIPT_PACKAGE="bash_include"

. bash_include
include basic

module_begin "${@}"

# path_remove_trailing_slash: gibt den pfad aus $1 ohne trailing slash auf stdout aus
path_remove_trailing_slash() (
	shopt -s extglob

	test ${1+set} || set -- "$(cat)"
	set -- "${1:-.}"
	set -- "${1%%*(/)}"
	printf "%s\n" "${1:-/}"
)

# simplyify_path: gibt vereinfachten pfad auf stdout aus.
path_simplify() (
	shopt -s extglob

	simplePath="/"
	pathPart=""
	path="${1-$(cat)}"
	path="${path//+('/')//}"
	IFS="/"
	for pathPart in ${path}; do
		if [ '.' == "${pathPart}" ]; then
			continue
		elif [ '..' == "${pathPart}" ]; then
			case "${simplePath}" in
			*/..//|/)
				simplePath+="..//"
			;;
			*/*//)
				simplePath="${simplePath%/*//}/"
			;;
			esac
		elif [ '' == "${pathPart}" ]; then
			simplePath+="${simplePath:-/}"
		else
			simplePath+="${pathPart}//"
		fi
	done
	simplePath="${simplePath:1}"
	simplePath="${simplePath:-.}"
	simplePath="${simplePath//\/\///}"
	simplePath="${simplePath%/}"
	simplePath="${simplePath:-/}"
	printf '%s\n' "${simplePath}"
)

# path_absolute: macht einen relativen pfad absolut, ausgehend entweder vom pfad in $1 (wenn $2
# gegeben ist), oder vom akktuellem arbeitsverzeichnis (wenn nur $1 gegeben ist).
path_absolute() (
	test ${1+set} || set -- "$(cat)"

	if [ ${2+set} ]; then
		source_path="$(path_absolute "$1")" ||
			return
		dest_path="$2"
	else
		source_path="${PWD}"
		dest_path="$1"
	fi

	if [ "${dest_path::1}" != "/" ]; then
		dest_path="${source_path}/${dest_path}"
	fi

	printf "%s\n" "${dest_path}"
)

# relative_path: gibt den relativen pfad von $1 zu $2 auf stdout aus.
path_relative() (
	test ${1+set} || set -- "$(cat)"

	if [ ${2+set} ]; then
		source_path="$(path_absolute "$1" | path_simplify)" ||
			return
		dest_path="$(path_absolute "$2" | path_simplify)" ||
			return
	else
		source_path="${PWD}"
		dest_path="$(path_absolute "$1" | path_simplify)" ||
			return
	fi

	#source-path und dest-path brauchen einen trailing slash, solange sie nicht rootpfad sind ("/"):
	test '/' != "${source_path}"&&
		source_path="${source_path}/"
	test '/' != "${dest_path}" &&
		dest_path="${dest_path}/"
	
	while [ "|${source_path%%/*}" == "|${dest_path%%/*}" ] && [ "${dest_path:+set}" ]; do
		dest_path="${dest_path#*/}"
		source_path="${source_path#*/}"
	done

	for garbage in ${source_path}; do
		dest_path="../${dest_path}"
	done
	
	path_remove_trailing_slash "${dest_path:-.}"
)

# path_is_absolute: gibt 0 zurueck, wenn der pfad aus $1 absolut ist.
path_is_absolute() {
	test ${1+set} || set -- "$(cat)"
	test ${1:+set} &&
		test '/' == "${1::1}"
}

# path_is_relative: gibt 0 zurueck, wenn der pfad aus $1 relativ ist.
path_is_relative() {
	test ${1+set} || set -- "$(cat)"
	test '/' != "${1::1}"
}

module_end "${@}"
