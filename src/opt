#!/bin/bash
# opt(opt) 1.9.5: command line parser
#                         supports gnu style longopts.
# functions:
#   opt_get(): command line parser.
#   opt_show_version(): shows script version
#   opt_show_usage(): shows short usage hint's based on the option array
#   opt_show_help(): shows more detailed help text
#   opt_check(): checks options for errors

SCRIPT_NAME="opt"
SCRIPT_PREFIX="opt"
SCRIPT_VERSION="1.9.5"
SCRIPT_DESCRIPTION="gnu style option parser"
SCRIPT_PACKAGE="bash_include"
SCRIPT_API="1"

. bash_include
include basic
include err
include var
include math

module_begin "${@}"
                        # global variables and constants:
opt_no_opt_count=0      # number of non-options in command line.
opt_no_options=()       # array of non-options.
opt_last_argument=0	    # last parsed command line argument
opt_additional_usage="" # use this to append information to the usage string
opt_additional_help=""  # use this to append information to the help screen

               # fields of an option record:
opt_TYPE=0     # specifies the type of an option (bOOL,  iNTEGER, rAW, sTRING).
opt_SHORT=1    # short names of an option.
opt_LONG=2     # long name of an option.
opt_ACTION=3   # what to do if an option is invoked.
opt_DEFAULT=4  # default value of an integer/raw/string option
opt_HELP=5     # help text for an option.

opt_show_version()
{
  	printf "%s " "${SCRIPT_PACKAGE}"
	printf "%s" "${SCRIPT_NAME:-$(basename "$0")}"
	printf "%s" "${SCRIPT_VERSION:+-${SCRIPT_VERSION}}"
	printf "\n"
}

opt_show_usage() {
	opt_show_version

	local _opt_aggregated_noparameter_options
	local _opt_aggregated_parameter_opts

	for _opt_option in "${!opt_option_@}"; do
		_opt_aggregate_short_opts "$_opt_option"
	done
	printf "Usage: %s%s\n" "${program_name}" "${_opt_aggregated_noparameter_options:+ -${_opt_aggregated_noparameter_options}}${_opt_aggregated_parameter_opts}${opt_additional_usage:+ ${opt_additional_usage}}"
	printf "Try '%s --help' for more information.\n" "${program_name}"
}

_opt_aggregate_short_opts() {
	local _opt_short="$1[opt_SHORT]"
	local _opt_type="$1[opt_TYPE]"
	local _opt_default="$1[opt_DEFAULT]"
	var_is_empty "$_opt_short" &&
		return
	case "${!_opt_type}" in
	[ifFIrRsS])
		_opt_aggregated_parameter_opts+=" -${!_opt_short}$(_opt_parameter_str "$1")"
	;;
	*)
		_opt_aggregated_noparameter_options+="${!_opt_short:0:1}"
	;;
	esac
}

_opt_parameter_str() {
	local _opt_type="$1[opt_TYPE]"
	local _opt_default="$1[opt_DEFAULT]"
	local -u result=${!_opt_type::1}
	var @{result/%[^iIfFrRsS]}
	var_is_empty result &&
		return
	var @{result/%I/INT}
	var @{result/%F/FLOAT}
	var @{result/%[RS]/STRING}
	echo "${!_opt_default+[}$2${result}${!_opt_default+]}"
}

opt_show_help() {
	local COLUMNS="${COLUMNS:-80}"
	local _opt_spacer="    "
	local _opt_max_option_syntax_length=0

	opt_show_usage
	printf "\n"

	local _opt_aggregated_option_syntax=()
	local _opt_aggregated_option_help=()
	local -i _opt_max_option_syntax_length=0
	for option in "${!opt_option_@}"; do
		_opt_aggregate_option_syntax_and_help "$option"
	done
	for additional_entry in ${!opt_additional_help_entry_@}; do
		_opt_aggregated_option_syntax+=( "$(@ "$additional_entry[0]")" )
		_opt_aggregated_option_help+=( "$(@ "$additional_entry[1]")" )
	_opt_max_option_syntax_length="$(math_max "$(@ "#$additional_entry[0]")" _opt_max_option_syntax_length)"
	done

	_opt_spacer="$(_opt_create_spacer $COLUMNS $_opt_max_option_syntax_length "    ")"
	for index in "${!_opt_aggregated_option_syntax[@]}"; do
		_opt_print_formated_help_line \
			"$COLUMNS" \
			"$_opt_spacer" \
			"${_opt_aggregated_option_syntax[index]}" \
			"${_opt_aggregated_option_help[index]}"
	done

	printf '%s\n' "${opt_additional_help}"
}

_opt_aggregate_option_syntax_and_help() {
	local _opt_short="$1[opt_SHORT]"
	local _opt_long="$1[opt_LONG]"
	local _opt_type="$1[opt_TYPE]"
	local _opt_default="$1[opt_DEFAULT]"
	local _opt_help="$1[opt_HELP]"
	local _opt_syntax
	local _opt_help
	if var_not_empty $_opt_short; then
		_opt_syntax="  -${!_opt_short::1}${!_opt_long:+,} "
	else
		_opt_syntax="      "
	fi
	var_not_empty "$_opt_long" &&
		_opt_syntax+="--${!_opt_long}$(_opt_parameter_str "$1" =)"
	_opt_aggregated_option_help+=("${!_opt_help}")
	_opt_aggregated_option_syntax+=("$_opt_syntax")
	_opt_max_option_syntax_length="$(math_max ${#_opt_syntax} _opt_max_option_syntax_length)"
}

_opt_create_spacer() {
	local -i "columns=$1"
	local -i "size=$2"
	if (( columns < 10 )); then
		echo " "
		return
	elif (( (columns - size) < 10 )); then
		echo "   "
		return
	else
		local spacer="    ";
		while (( ${#spacer} < size )); do
			spacer+="$spacer"
		done
		echo "${spacer::size} "
	fi
}

_opt_print_formated_help_line() {
	local -i "columns=$1"
	local "spacer=$2"
	local "line=$3${spacer::${#spacer}-${#3}}$4"
	local part
	while (( ${#line} > columns )); do
		part="${line::columns}"
		line="${spacer}${part##*[[:space:]]}${line: columns}"
		var @{part%[[:space:]]*}
		printf '%s\n' "$part"
	done
	printf '%s\n' "$line"
}

opt_get() {
	# create a hash string to find options fast:
	_opt_create_hashs
	opt_last_argument=1
	while ${!opt_last_argument+true} false; do
		(( _opt_next_argument = opt_last_argument + 1 ))
		case "${!opt_last_argument}" in
		-)
			opt_no_option+=("${!opt_last_argument}")
		;;
		--)
			shift
			opt_no_options+=("${@:opt_last_argument}")
			break
		;;
		--=*)
			opt_bad_option "malformed option" "${!opt_last_argument}"
			return
		;;
		--*=*)
			_opt_get_long_option "${!opt_last_argument%%=*}" "${!opt_last_argument#*=}" ||
				return
		;;
		--*--*)
			opt_bad_option "malformed option" "${!opt_last_argument}"
			return
		;;
		--*)
			_opt_get_long_option "${!opt_last_argument}" ||
				return
		;;
		-*)
			_opt_get_short_option "${!opt_last_argument}" ${!_opt_next_argument} ||
				return
		;;
		*)
			opt_no_options+=("${!opt_last_argument}")
		;;
		esac
		(( ++opt_last_argument ))
	done
	return 0
}

_opt_create_hashs() {
	# localy used variables  #
	local opt
	local short

	for opt in "${!opt_option_@}"; do
		short="$(@ "${opt}[opt_SHORT]")"
		while (( ${#short} )); do
			opt_SHASH="$opt_SHASH-${short:0:1}:${opt##opt_option_}"
			short=${short:1}
		done
		opt_LHASH="$opt_LHASH--$(@ "${opt}[opt_LONG]"):${opt##opt_option_}"
	done
}


_opt_get_long_option() {
	_opt_invoke_option "$(_opt_option_for_long_option "$1")" "$1" ${2+"$2"}
}

_opt_option_for_long_option() {
	local _opt_suffix="opt_option_${opt_LHASH#*"$1":}"
	echo "${_opt_suffix%%--*}"
}

_opt_get_short_option() {
	local _opt_string="$1"
	local _opt_short_option
	local _opt_parameter
	local _opt_option
	while (( ${#_opt_string} > 1 )); do
		_opt_short_option="${_opt_string::2}"
		_opt_parameter="${_opt_string:2}"
		_opt_option="$(_opt_option_for_short_option "$_opt_short_option")"
		_opt_invoke_option \
			"${_opt_option}"\
			"${_opt_short_option}" \
			${_opt_parameter:+"${_opt_parameter}"} \
			${2+"$2"} ||
				return
		if ! _opt_is_boolean "${_opt_option}"; then
			if test -z "${_opt_parameter}"; then
				(( ++opt_last_argument ))
			fi
			return 0
		fi
		_opt_string="-${_opt_string:2}"
	done
}

_opt_option_for_short_option() {
	local _opt_suffix="${opt_SHASH#*"$1":}"
	echo "opt_option_${_opt_suffix%%-*}"
}

_opt_is_boolean() {
	local _opt_type="$1[opt_TYPE]"
	test "b" == "${!_opt_type/B/b}"
}

_opt_invoke_option() {
	local _opt_option="$1"
	local _opt_string="$2"
	local _opt_type="$1[opt_TYPE]"
	local _opt_default="$1[opt_DEFAULT]"
	local _opt_action="$1[opt_ACTION]"
	if var_not_set "$_opt_option"; then
		opt_bad_option 'unknown option' "$2"; return
	fi
	set -- ${3+"$3"} ${4+"$4"} ${!_opt_default+"${!_opt_default}"}
	local parameter${1+="$1"}
	_opt_check_value "$_opt_type" "$_opt_string" ${parameter+"${parameter}"} ||
		return
	eval "${!_opt_action}"
}

_opt_check_value() {
	case "${!1}" in
	[iI])
		math_is_int "$3" ||
			opt_bad_option 'option needs an integer value' "$2"
	;;
	[fF])
		math_is_float "$3" ||
			opt_bad_option 'option needs an floating point value' "$2"
	;;
	[sS])
		${3:+true} false ||
			opt_bad_option 'option requires a non-empty parameter' "$2"
	;;
	[rR])
		${3+true} false ||
			opt_bad_option 'missing parameter for option' "$2"
	;;
	esac
}

opt_bad_option() (
	printf '%s: %s: %s\n' "${program_name}" "${1}" "${2}" 1>&2
  	opt_show_usage
	return ${err_INVAL}
)

module_end "${@}"
