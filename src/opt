#!/bin/bash
# opt(opt) 1.9.5: command line parser
#                         supports gnu style longopts.
# functions:
#   opt_get(): command line parser.
#   opt_show_version(): shows script version
#   opt_show_usage(): shows short usage hint's based on the option array
#   opt_show_help(): shows more detailed help text
#   opt_check(): checks options for errors

SCRIPT_NAME="opt"
SCRIPT_PREFIX="opt"
SCRIPT_VERSION="1.9.5"
SCRIPT_DESCRIPTION="gnu style option parser"
SCRIPT_PACKAGE="bash_include"
SCRIPT_API="1"

. bash_include
include basic
include err
include var
include math

module_begin "${@}"
                        # global variables and constants:
opt_no_opt_count=0      # number of non-options in command line.
opt_no_options=()       # array of non-options.
opt_last_argument=0	    # last parsed command line argument
opt_additional_usage="" # use this to append information to the usage string
opt_additional_help=""  # use this to append information to the help screen

               # fields of an option record:
opt_TYPE=0     # specifies the type of an option (bOOL,  iNTEGER, rAW, sTRING).
opt_SHORT=1    # short names of an option.
opt_LONG=2     # long name of an option.
opt_ACTION=3   # what to do if an option is invoked.
opt_DEFAULT=4  # default value of an integer/raw/string option
opt_HELP=5     # help text for an option.

opt_show_version()
{
  	printf "%s " "${SCRIPT_PACKAGE}"
	printf "%s" "${SCRIPT_NAME:-$(basename "$0")}"
	printf "%s" "${SCRIPT_VERSION:+-${SCRIPT_VERSION}}"
	printf "\n"
}

opt_show_usage() {
	opt_show_version

	set -- "${!opt_option_@}"
	while ${1+true} false; do
		_opt_aggregate_short_opts "$1"
		shift
	done
	printf "Usage: %s%s\n" "${program_name}" "${_opt_aggregated_noparameter_options:+ -${_opt_aggregated_noparameter_options}}${_opt_aggregated_parameter_opts}${opt_additional_usage:+ ${opt_additional_usage}}"
	printf "Try '%s --help' for more information.\n" "${program_name}"
}

_opt_aggregate_short_opts() {
	set -- "$1[opt_SHORT]" "$1[opt_TYPE]" "$1[opt_DEFAULT]"
	var_is_empty "$1" &&
		return
	case "${!2}" in
	[ifFIrRsS])
		_opt_aggregated_parameter_opts+=" -${!1:0:1}${!3+[}$(_opt_type_str "${!2}")${!3+]}"
	;;
	*)
		_opt_aggregated_noparameter_options+="${!1:0:1}"
	;;
	esac
}

_opt_type_str() {
	set -- "${1/[iI]/INT}"
	set -- "${1/[fF]/FLOAT}"
	echo "${1/[rRsS]/STRING}"
}

opt_show_help() (
	spacer="    "
	_opt_max_option_syntax_length=0

	opt_show_usage
	printf "\n"

	_opt_aggregated_option_syntax=()
	_opt_aggregated_option_help=()
	local -i _opt_max_option_syntax_length=0

	for option in "${!opt_option_@}"; do
		_opt_aggregate_option_syntax_and_help "$option"
	done
	help_text=("${_opt_aggregated_option_syntax[@]}");

	COLUMNS="${COLUMNS:-80}"
	spacer="$(_opt_create_spacer $COLUMNS $_opt_max_option_syntax_length "    ")"
	for index in "${!_opt_aggregated_option_syntax[@]}"; do
		_opt_print_formated_help_line \
			"$COLUMNS" \
			"$spacer" \
			"${_opt_aggregated_option_syntax[index]}" \
			"${_opt_aggregated_option_help[index]}"
	done

	for additional_entry in ${!opt_additional_help_entry_@}; do
		_opt_print_formated_help_line \
			"$COLUMNS" \
			"$spacer" \
			"$(@ "${additional_entry}[0]")" \
			"$(@ "${additional_entry}[1]")"
	done

	printf '%s\n' "${opt_additional_help}"
)

_opt_aggregate_option_syntax_and_help() {
	set -- "$1[opt_LONG]" "$1[opt_SHORT]" "$1[opt_TYPE]" "$1[opt_DEFAULT]" "$1[opt_HELP]"
	if ${!2:+true} false; then
		set -- "${@:1:5}" "  -${!2:0:1}${!1:+,} "
	else
		set -- "${@:1:5}" "      "
	fi
	if ${!1:+true} false; then
		set -- "$@""--${!1}"
	fi
	case "${!3}" in
	[iIfFrRsS])
		if ${!1:+true} false; then
			set -- "$@""${!4+[}=$(_opt_type_str "${!3}")${!4+]}"
		elif ${!2:+true} false; then
			set -- "$@""${!4+[}$(_opt_type_str "${!3}")${!4+]}"
		fi
	;;
	esac
	_opt_aggregated_option_help+=("${!5}")
	_opt_aggregated_option_syntax+=("$6")
	_opt_max_option_syntax_length="$(math_max ${#6} _opt_max_option_syntax_length)"
}

_opt_create_spacer() {
	if (( "$1" < 10 )); then
		echo " "
		return
	elif (( ("$1" - "$2") < 10 )); then
		echo "   "
		return
	else
		set -- "$2" "    "
		while (( ${#2} < "$1" )); do
			set -- "$1" "$2$2"
		done
		echo "${2::$1} "
	fi
}

_opt_print_formated_help_line() {
	set -- "$1" "$2" "$3${2::${#2} - ${#3}}$4"
	while (( ${#3} > "$1" )); do
		set -- "$1" "$2" "$3" "${3:: $1 - 1}"
		set -- "$1" "$2" "${4##*[[:space:]]}${3#[[:space:]]}" "${4%[[:space:]]*}"
		printf '%s\n' "${4}"
		set -- "$1" "$2" "$2${3: $1 - 2}"
	done
	printf '%s\n' "${3}"
}

opt_get() {
	# localy used variables  #
	local opt
	local short

	# create a hash string to find options fast:
	for opt in "${!opt_option_@}"; do
		short="$(@ "${opt}[opt_SHORT]")"
		while (( ${#short} )); do
			opt_SHASH="$opt_SHASH-${short:0:1}:${opt##opt_option_}"
			short=${short:1}
		done
		opt_LHASH="$opt_LHASH--$(@ "${opt}[opt_LONG]"):${opt##opt_option_}"
	done

	opt_last_argument=1
	while ${!opt_last_argument+true} false; do
		(( _opt_next_argument = opt_last_argument + 1 ))
		case "${!opt_last_argument}" in
		-)
			opt_no_option+=("${!opt_last_argument}")
		;;
		--)
			shift
			opt_no_options+=("${@:opt_last_argument}")
			break
		;;
		--=*)
			opt_bad_option "malformed option" "${!opt_last_argument}"
			return
		;;
		--*=*)
			_opt_get_long_option "${!opt_last_argument%%=*}" "${!opt_last_argument#*=}" ||
				return
		;;
		--*--*)
			opt_bad_option "malformed option" "${!opt_last_argument}"
			return
		;;
		--*)
			_opt_get_long_option "${!opt_last_argument}" ||
				return
		;;
		-*)
			_opt_get_short_option "${!opt_last_argument}" ${!_opt_next_argument} ||
				return
		;;
		*)
			opt_no_options+=("${!opt_last_argument}")
		;;
		esac
		(( ++opt_last_argument ))
	done
	return 0
}

_opt_get_long_option() {
	set -- "${opt_LHASH#*"$1":}" "$1" ${2+"$2"}
	_opt_invoke_option "opt_option_${1%%--*}" "$2" ${3+"$3"}
}

_opt_get_short_option() {
	while (( ${#1} > 1 )); do
		set -- "${opt_SHASH#*"${1::2}":}" "$1" ${2+"$2"}
		set -- "opt_option_${1%%-*}" "$2" ${3+"$3"}
		_opt_invoke_option "$1" "${2::2}" "${2:2}" ${3+"$3"} ||
			return
		if test -n "${!1#[bB]}"; then
			if test -z "${2:2}"; then
				(( ++opt_last_argument ))
			fi
			return 0
		fi
		set -- "-${2:2}" ${3+"$3"}
	done
}

_opt_invoke_option() {
	if ${!1+false} true; then
		opt_bad_option 'unknown option' "${3::2}"; return
	fi
	set -- "$1" "$2" "$1[opt_DEFAULT]" ${3:+"$3"} ${4+"$4"}
	set -- "$1" "$2" ${4+"$4"} ${!3+"${!3}"}
    _opt_check_value "$1[opt_TYPE]" "${2}" ${3+"$3"} ||
		return
	local parameter${3+"=$3"}
	set -- "$1[opt_ACTION]"
	eval "${!1}"
}

_opt_check_value() {
	case "${!1}" in
	[iI])
		math_is_int "$3" ||
			opt_bad_option 'option needs an integer value' "$2"
	;;
	[fF])
		math_is_float "$3" ||
			opt_bad_option 'option needs an floating point value' "$2"
	;;
	[sS])
		${3:+true} false ||
			opt_bad_option 'option requires a non-empty parameter' "$2"
	;;
	[rR])
		${3+true} false ||
			opt_bad_option 'missing parameter for option' "$2"
	;;
	esac
}

opt_bad_option() (
	printf '%s: %s: %s\n' "${program_name}" "${1}" "${2}" 1>&2
  	opt_show_usage
	return ${err_INVAL}
)

module_end "${@}"
