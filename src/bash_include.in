#!/bin/bash

test ${BASH_INCLUDE+set} &&
	return
BASH_INCLUDE=true

is_included()
{
	local IFS=$'\n'
	case "${IFS}${BASH_INCLUDE_INCLUDED[*]}${IFS}" in
		*"${IFS}$1${IFS}"*)
		    return 0
		;;
	esac
	return 1
}

include()
{
	if ! try_include "$@"; then
		printf '%s: include not found: %s\n' "$0" "$1" 1>&2
		exit
	fi
}

try_include()
{
	is_included "$1" &&
		return 0

	force_include "$1"
}

force_include()
{
	local "${!SCRIPT_@}"
	local BASH_INCLUDE_INCLUDING="true"
	local included include_path path var

	case "$1" in
		*[^A-Za-z0-9_/]*|*__*)
			printf "%s: invalid include name: %s\n" "$0" "$1" 1>&2
			return 1
		;;
	esac

	# convert path for easy parsing
	include_path="${BASH_INCLUDE_PATH:-/usr/lib/bash:/usr/local/lib/bash}"
	include_path="${include_path//-/-+}"
	include_path="${include_path//\\\\/-b}"
	include_path="${include_path//\\:/-d}"
	include_path="${include_path//\\/}"

	# do parsing
	local IFS=':'
	for path in ${include_path}; do
		path="${path//-d/:}"
		path="${path//-b/\\}"
		path="${path//-+/-}"
		${DEBUG+set} && echo "search in ${path}"
		if [ -r "${path}/${1}" ]; then
			. "${path}/${1}"
			SCRIPT_API="${SCRIPT_API:-0}"
#TODO: check if other function could result to correct version check. eval may be to strange
			for var in "${!SCRIPT_@}"; do
				test ${!var:+set} &&
					eval "BASH_INCLUDE_X${1//\//__}_${var#SCRIPT_}=\"\${!var}\""
			done
			unset "${!SCRIPT_@}"

			is_included "$1" ||
				BASH_INCLUDE_INCLUDED+=("$1")
			return 0;
		fi
	done
	return 1
}
